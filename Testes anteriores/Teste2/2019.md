[Link to test](https://drive.google.com/drive/folders/1MngkqQ8Iqumq8xZteWe61fOYSOQFKg4N)

## Resolução

**1.**

N presentes
K pessoas
Variáveis binárias

| | 1 | 2 |... | K |
|---|---|---|---|---|
| 1 |   |   |   |   |
| 2 |   |   |   |   |
|...|   |   |   |   |
| N |   |   |   |   |

[1,1], [1,2], ..., [1,K], [2,1], ..., [N, K]

N * K variáveis

2 variáveis de domínio binárias: N e K.

Dimensão: 2<sup>NK</sup> => Opção A

----

**2.**

Domínio: K
Variáveis de domínio: N

Dimensão: K<sup>N</sup> => Opção C

----

**3.**

```pl
pres(N, K, Vars):-
	length(Vars, N),
	domain(Vars, 1, K),
	%
	indices(1, Vars),
	%
	labeling([], Vars).

indices(I, [V | Vs]):-
	V mod 2 #\= I mod 2,
	I1 is I + 1,
	indices(I1, Vs).

indices(_, []).
```

Este programa cria uma lista com tamanho igual ao número de presentes (N) e cujo domínio varia entre 1 e o número de pessoas (K). Assim, cria-se uma lista que contém os números das pessoas (uma por posição) que receberam o presente com o número dessa posição. Por exemplo, se Vars = [2, 5, 4], então significa que a pessoa 2 recebeu o presente 1, a pessoa 5 recebeu o presente 2 e a pessoa 4 recebeu o presente 3.
Através da chamada à função índicies, cria-se uma restrição que garante que as pessoas ímpares só recebem presentes pares e que as pessoas pares só recebem presentes ímpares.
Assim, depois de feito o labeling, obtém-se uma lista que contém alternadamente, números pares e ímpares que correspondem ao número da pessoa que recebeu o presente com o número dessa posição.

**4.**

**5.**

**6.**

O comprimento da lista de variáveis de decisão vai ser igual ao comprimento da lista de objetos, uma vez que a cada objeto vai corresponder uma determinada posição.
O domínio atribuído à lista de variáveis vai ter como limite inferior 1 e como limite superior o número de compartimentos existente, que pode ser obtido multiplicando o número de compartimentos existentes em altura pelo número de compartimentos existente em largura.
Assim, a lista Vars vai ser uma lista com comprimento igual ao número de objetos em que o número em cada posiçao indica o compartimento no armário em que esse elemento vai ficar armazenado.
Por exemplo, se Vars = [3,1,3,4,1,4], isto significa que o no compartimento 3 vão ficar os objetos com índice 1 e 3, no compartimento 1 vão ficar os objetos com índice 2 e 5 e no compartimento 4 vão ficar os objetos com índice 4 e 6.
Para se resolver o problema, é necessário impôr um limite ao volume de cada compartimento, pelo que é preciso impôr uma restrição de modo a que a soma dos volumes armazenados em cada compartimento não seja superior à capacidade de armazenamento desse compartimento.
Para ser possível aplicar a restrição de que nenhum compartimento tem peso superior ao compartimento que se encontra em baixo deste. Para isso, é preciso obter o peso de cada compartimento numa lista de seqeência (da esquerda para a direita, de cima para baixo do armário), e restringir que o peso de cada compartimento não pode ser inferior ao peso do compartimento que se encontra NC compartimentos antes, em que NC é o número de compartimentos por linha.


